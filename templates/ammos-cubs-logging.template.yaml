# TODO:
# - more parameterization
# - cognito based authentication for access to kibana
# - can service-linked role be created in this template?

AWSTemplateFormatVersion: 2010-09-09
Description: Logging resources for an AMMOS Cubs Deployment


Parameters:
  BastionAmiId:
    Description: AMI to use for the Elasticsearch bastion host
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2
  ElasticsearchDomainName:
    Description: Name of the Elasticsearch domain
    Type: String
  CloudWatchLogsRetentionPeriod:
    Description: The number of days to retain log events in CloudWatch log groups
    Type: Number
    Default: 30
  # TODO: Enforce AllowedValues
  PermissionsBoundaryArn:
    Description: Will be attached to all created IAM Roles to satisfy security requirements
    Type: String
  # TODO: Enforce AllowedValues
  RolePath:
    Description: Will be attached to all created IAM Roles to satisfy security requirements
    Type: String
  SshKeyName:
    Description: SSH key to use for access to bastion host
    Type: String


Conditions:
  RolePathProvided: !Not [!Equals ['', !Ref RolePath]]
  PermissionsBoundaryProvided: !Not [!Equals ['', !Ref PermissionsBoundaryArn]]


Resources:
  ElasticsearchSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: vpc-03456b468daa53da4 # TODO: parameterize
      GroupDescription: Security group for access to AMMOS Cubs Elasticsearch domain.
      SecurityGroupIngress: # TODO: parameterize?
        - CidrIp: 128.149.0.0/16
          Description: JPL Internal
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
        - CidrIp: 137.78.0.0/16
          Description: JPL Internal
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
        - CidrIp: 137.79.0.0/16
          Description: JPL Internal
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443

  ElasticsearchSecurityGroupIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !GetAtt ElasticsearchSecurityGroup.GroupId
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !GetAtt ElasticsearchSecurityGroup.GroupId

  ElasticsearchDomain:
    Type: AWS::Elasticsearch::Domain
    Properties:
      DomainName: !Ref ElasticsearchDomainName
      ElasticsearchVersion: "7.10"
      ElasticsearchClusterConfig:
        DedicatedMasterCount: 3
        DedicatedMasterEnabled: true
        DedicatedMasterType: t3.medium.elasticsearch
        InstanceType: t3.medium.elasticsearch
        InstanceCount: 2
        ZoneAwarenessEnabled: true
      EBSOptions:
        EBSEnabled: true
        VolumeSize: 10
        VolumeType: gp2
      EncryptionAtRestOptions:
        Enabled: true
        # KmsKeyId: c969e1d8-2107-4ffb-8e92-6821f1c58e9b # AWS managed key "aws/es"
      NodeToNodeEncryptionOptions:
        Enabled: true
      DomainEndpointOptions:
        EnforceHTTPS: true
        TLSSecurityPolicy: Policy-Min-TLS-1-2-2019-07
      VPCOptions:
        SubnetIds:
          - subnet-03a1ec6be37d72106 # Private - 1A TODO: parameterize
          - subnet-09abda62751c89495 # Private - 1B TODO: parameterize
        SecurityGroupIds:
          - !GetAtt ElasticsearchSecurityGroup.GroupId
      AccessPolicies:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              AWS: "*"
            Action: es:*
            Resource: !Sub arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${ElasticsearchDomainName}/*

  LoggingLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: !If [RolePathProvided, !Ref RolePath, !Ref AWS::NoValue]
      PermissionsBoundary:  !If [PermissionsBoundaryProvided, !Ref PermissionsBoundaryArn, !Ref AWS::NoValue]
      Policies:
        - PolicyName: logging-lambda-execution
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - es:*
                Resource: !Sub arn:${AWS::Partition}:es:${AWS::Region}:${AWS::AccountId}:domain/${ElasticsearchDomainName}/*
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole

  LoggingLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: CloudWatch Logs to Amazon ES streaming
      Handler: index.handler
      Role: !GetAtt LoggingLambdaExecutionRole.Arn
      Runtime: nodejs12.x
      Timeout: 60
      VpcConfig:
        SecurityGroupIds:
          - !GetAtt ElasticsearchSecurityGroup.GroupId
        SubnetIds:
          - subnet-09abda62751c89495 # Private - 1B # TODO: parameterize
          - subnet-03a1ec6be37d72106 # Private - 1A # TODO: parameterize
          - subnet-0dd1d301a34b4db58 # Private - 1C # TODO: parameterize
      Environment:
        Variables:
          ES_DOMAIN_URL: !GetAtt ElasticsearchDomain.DomainEndpoint
          LOG_FAILED_RESPONSES: true
      Code:
        # Code below generated from log group -> "Subscription filters" -> "Create Elasticsearch subscription filter" Lambda function
        ZipFile: |
          // v1.1.2
          var https = require('https');
          var zlib = require('zlib');
          var crypto = require('crypto');

          var endpoint = process.env.ES_DOMAIN_URL;

          // Set this to true if you want to debug why data isn't making it to
          // your Elasticsearch cluster. This will enable logging of failed items
          // to CloudWatch Logs.
          var logFailedResponses = process.env.LOG_FAILED_RESPONSES === "true" ? true : false;

          exports.handler = function(input, context) {
              // decode input from base64
              var zippedInput = new Buffer.from(input.awslogs.data, 'base64');

              // decompress the input
              zlib.gunzip(zippedInput, function(error, buffer) {
                  if (error) { context.fail(error); return; }

                  // parse the input from JSON
                  var awslogsData = JSON.parse(buffer.toString('utf8'));

                  // transform the input to Elasticsearch documents
                  var elasticsearchBulkData = transform(awslogsData);

                  // skip control messages
                  if (!elasticsearchBulkData) {
                      console.log('Received a control message');
                      context.succeed('Control message handled successfully');
                      return;
                  }

                  // post documents to the Amazon Elasticsearch Service
                  post(elasticsearchBulkData, function(error, success, statusCode, failedItems) {
                      console.log('Response: ' + JSON.stringify({
                          "statusCode": statusCode
                      }));

                      if (error) {
                          logFailure(error, failedItems);
                          context.fail(JSON.stringify(error));
                      } else {
                          console.log('Success: ' + JSON.stringify(success));
                          context.succeed('Success');
                      }
                  });
              });
          };

          function transform(payload) {
              if (payload.messageType === 'CONTROL_MESSAGE') {
                  return null;
              }

              var bulkRequestBody = '';

              payload.logEvents.forEach(function(logEvent) {
                  var timestamp = new Date(1 * logEvent.timestamp);

                  // index name format: cwl-YYYY.MM.DD
                  var indexName = [
                      'cwl-' + timestamp.getUTCFullYear(),              // year
                      ('0' + (timestamp.getUTCMonth() + 1)).slice(-2),  // month
                      ('0' + timestamp.getUTCDate()).slice(-2)          // day
                  ].join('.');

                  var source = buildSource(logEvent.message, logEvent.extractedFields);
                  source['@id'] = logEvent.id;
                  source['@timestamp'] = new Date(1 * logEvent.timestamp).toISOString();
                  source['@message'] = logEvent.message;
                  source['@owner'] = payload.owner;
                  source['@log_group'] = payload.logGroup;
                  source['@log_stream'] = payload.logStream;

                  var action = { "index": {} };
                  action.index._index = indexName;
                  action.index._type = payload.logGroup;
                  action.index._id = logEvent.id;

                  bulkRequestBody += [
                      JSON.stringify(action),
                      JSON.stringify(source),
                  ].join('\n') + '\n';
              });
              return bulkRequestBody;
          }

          function buildSource(message, extractedFields) {
              if (extractedFields) {
                  var source = {};

                  for (var key in extractedFields) {
                      if (extractedFields.hasOwnProperty(key) && extractedFields[key]) {
                          var value = extractedFields[key];

                          if (isNumeric(value)) {
                              source[key] = 1 * value;
                              continue;
                          }

                          var jsonSubString = extractJson(value);
                          if (jsonSubString !== null) {
                              source['$' + key] = JSON.parse(jsonSubString);
                          }

                          source[key] = value;
                      }
                  }
                  return source;
              }

              var jsonSubString = extractJson(message);
              if (jsonSubString !== null) {
                  return JSON.parse(jsonSubString);
              }

              return {};
          }

          function extractJson(message) {
              var jsonStart = message.indexOf('{');
              if (jsonStart < 0) return null;
              var jsonSubString = message.substring(jsonStart);
              return isValidJson(jsonSubString) ? jsonSubString : null;
          }

          function isValidJson(message) {
              try {
                  JSON.parse(message);
              } catch (e) { return false; }
              return true;
          }

          function isNumeric(n) {
              return !isNaN(parseFloat(n)) && isFinite(n);
          }

          function post(body, callback) {
              var requestParams = buildRequest(endpoint, body);

              var request = https.request(requestParams, function(response) {
                  var responseBody = '';
                  response.on('data', function(chunk) {
                      responseBody += chunk;
                  });

                  response.on('end', function() {
                      var info = JSON.parse(responseBody);
                      var failedItems;
                      var success;
                      var error;

                      if (response.statusCode >= 200 && response.statusCode < 299) {
                          failedItems = info.items.filter(function(x) {
                              return x.index.status >= 300;
                          });

                          success = {
                              "attemptedItems": info.items.length,
                              "successfulItems": info.items.length - failedItems.length,
                              "failedItems": failedItems.length
                          };
                      }

                      if (response.statusCode !== 200 || info.errors === true) {
                          // prevents logging of failed entries, but allows logging
                          // of other errors such as access restrictions
                          delete info.items;
                          error = {
                              statusCode: response.statusCode,
                              responseBody: info
                          };
                      }

                      callback(error, success, response.statusCode, failedItems);
                  });
              }).on('error', function(e) {
                  callback(e);
              });
              request.end(requestParams.body);
          }

          function buildRequest(endpoint, body) {
              var endpointParts = endpoint.match(/^([^\.]+)\.?([^\.]*)\.?([^\.]*)\.amazonaws\.com$/);
              var region = endpointParts[2];
              var service = endpointParts[3];
              var datetime = (new Date()).toISOString().replace(/[:\-]|\.\d{3}/g, '');
              var date = datetime.substr(0, 8);
              var kDate = hmac('AWS4' + process.env.AWS_SECRET_ACCESS_KEY, date);
              var kRegion = hmac(kDate, region);
              var kService = hmac(kRegion, service);
              var kSigning = hmac(kService, 'aws4_request');

              var request = {
                  host: endpoint,
                  method: 'POST',
                  path: '/_bulk',
                  body: body,
                  headers: {
                      'Content-Type': 'application/json',
                      'Host': endpoint,
                      'Content-Length': Buffer.byteLength(body),
                      'X-Amz-Security-Token': process.env.AWS_SESSION_TOKEN,
                      'X-Amz-Date': datetime
                  }
              };

              var canonicalHeaders = Object.keys(request.headers)
                  .sort(function(a, b) { return a.toLowerCase() < b.toLowerCase() ? -1 : 1; })
                  .map(function(k) { return k.toLowerCase() + ':' + request.headers[k]; })
                  .join('\n');

              var signedHeaders = Object.keys(request.headers)
                  .map(function(k) { return k.toLowerCase(); })
                  .sort()
                  .join(';');

              var canonicalString = [
                  request.method,
                  request.path, '',
                  canonicalHeaders, '',
                  signedHeaders,
                  hash(request.body, 'hex'),
              ].join('\n');

              var credentialString = [ date, region, service, 'aws4_request' ].join('/');

              var stringToSign = [
                  'AWS4-HMAC-SHA256',
                  datetime,
                  credentialString,
                  hash(canonicalString, 'hex')
              ] .join('\n');

              request.headers.Authorization = [
                  'AWS4-HMAC-SHA256 Credential=' + process.env.AWS_ACCESS_KEY_ID + '/' + credentialString,
                  'SignedHeaders=' + signedHeaders,
                  'Signature=' + hmac(kSigning, stringToSign, 'hex')
              ].join(', ');

              return request;
          }

          function hmac(key, str, encoding) {
              return crypto.createHmac('sha256', key).update(str, 'utf8').digest(encoding);
          }

          function hash(str, encoding) {
              return crypto.createHash('sha256').update(str, 'utf8').digest(encoding);
          }

          function logFailure(error, failedItems) {
              if (logFailedResponses) {
                  console.log('Error: ' + JSON.stringify(error, null, 2));

                  if (failedItems && failedItems.length > 0) {
                      console.log("Failed Items: " +
                          JSON.stringify(failedItems, null, 2));
                  }
              }
          }

  AitEditorAgentLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /cloudwatch-agent/ait-editor/agent
      RetentionInDays: !Ref CloudWatchLogsRetentionPeriod

  AitEditorSyslogLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /cloudwatch-agent/ait-editor/syslog
      RetentionInDays: !Ref CloudWatchLogsRetentionPeriod

  AitServerAgentLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /cloudwatch-agent/ait-server/agent
      RetentionInDays: !Ref CloudWatchLogsRetentionPeriod

  AitServerSyslogLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /cloudwatch-agent/ait-server/syslog
      RetentionInDays: !Ref CloudWatchLogsRetentionPeriod

  AitEditorAgentSubscriptionFilter:
    DependsOn:
      - AitEditorAgentInvokePermission
    Type: AWS::Logs::SubscriptionFilter
    Properties:
      LogGroupName: !Ref AitEditorAgentLogGroup
      DestinationArn: !GetAtt LoggingLambda.Arn
      FilterPattern: ""

  AitEditorSyslogSubscriptionFilter:
    DependsOn:
      - AitEditorSyslogInvokePermission
    Type: AWS::Logs::SubscriptionFilter
    Properties:
      LogGroupName: !Ref AitEditorSyslogLogGroup
      DestinationArn: !GetAtt LoggingLambda.Arn
      FilterPattern: ""

  AitServerAgentSubscriptionFilter:
    DependsOn:
      - AitServerAgentInvokePermission
    Type: AWS::Logs::SubscriptionFilter
    Properties:
      LogGroupName: !Ref AitServerAgentLogGroup
      DestinationArn: !GetAtt LoggingLambda.Arn
      FilterPattern: ""

  AitServerSyslogSubscriptionFilter:
    DependsOn:
      - AitServerSyslogInvokePermission
    Type: AWS::Logs::SubscriptionFilter
    Properties:
      LogGroupName: !Ref AitServerSyslogLogGroup
      DestinationArn: !GetAtt LoggingLambda.Arn
      FilterPattern: ""

  AitEditorAgentInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt LoggingLambda.Arn
      Action: lambda:InvokeFunction
      Principal: logs.amazonaws.com
      SourceArn: !GetAtt AitEditorAgentLogGroup.Arn
      SourceAccount: !Ref AWS::AccountId

  AitEditorSyslogInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt LoggingLambda.Arn
      Action: lambda:InvokeFunction
      Principal: logs.amazonaws.com
      SourceArn: !GetAtt AitEditorSyslogLogGroup.Arn
      SourceAccount: !Ref AWS::AccountId

  AitServerAgentInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt LoggingLambda.Arn
      Action: lambda:InvokeFunction
      Principal: logs.amazonaws.com
      SourceArn: !GetAtt AitServerAgentLogGroup.Arn
      SourceAccount: !Ref AWS::AccountId

  AitServerSyslogInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt LoggingLambda.Arn
      Action: lambda:InvokeFunction
      Principal: logs.amazonaws.com
      SourceArn: !GetAtt AitServerSyslogLogGroup.Arn
      SourceAccount: !Ref AWS::AccountId

  Ec2SecurityGroupSsh:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: vpc-03456b468daa53da4 # TODO: parameterize
      GroupDescription: Security group for access to bastion.
      SecurityGroupIngress: # TODO: parameterize?
        - CidrIp: 128.149.0.0/16
          Description: JPL Internal
          IpProtocol: tcp
          FromPort: 22
          ToPort: 22
        - CidrIp: 137.78.0.0/16
          Description: JPL Internal
          IpProtocol: tcp
          FromPort: 22
          ToPort: 22
        - CidrIp: 137.79.0.0/16
          Description: JPL Internal
          IpProtocol: tcp
          FromPort: 22
          ToPort: 22

  ElasticsearchBastion:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref BastionAmiId
      InstanceType: t2.micro
      KeyName: !Ref SshKeyName
      NetworkInterfaces:
        - AssociatePublicIpAddress: true
          DeleteOnTermination: true
          DeviceIndex: "0"
          GroupSet:
            - !Ref Ec2SecurityGroupSsh
            - !Ref ElasticsearchSecurityGroup
          SubnetId: subnet-03a1ec6be37d72106 # Private - 1A
      Tags:
        - Key: Name
          Value: ammo-cubs-logging-bastion
